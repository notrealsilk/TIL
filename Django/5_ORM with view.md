# ORM with view

장고 shell에서 연습했던 **QuerySet API를 직접 view 함수에서 사용**하기

---

1. 전체 게시글 조회
2. 단일 게시글 조회

---

## Read

### 전체 게시글 조회

### 단일 게시글 조회

: 특정한 페이지의 상세 페이지

### pk(기본키)가 1인 페이지


- variable routing.. `<int:pk>/` <타입 : 변수명>/
    

---

### 단일 게시글 페이지 링크 작성


## Create

### create를 구현하기 위해 필요한 view 함수 (2)

- `new` : 사용자 입력 데이터를 받을 페이지를 렌더링
- `create` : 사용자가 입력한 요청 데이터를 받아 db에 저장

### new

`form` 태그 : 서버로 요청을 보냄

`input` 태그 : 입력을 받는 태그로, form태그 안에서 사용 

```
          {% comment %} name: 서버로 전송할 때 데이터의 키 역할 {% endcomment %}
          {% comment %} id: HTML 문서 내에서 요소를 식별 {% endcomment %}
```

---

- 서버의 데이터는 `키(html 태그의 name)=값(사용자가 입력한 값)`으로 넘어감

---



### create

: 응답 페이지를 반환

# HTTP request methods

- 데이터에 대해 수행을 원하는 **작업(행동)**을 나타내는 것 (2)

(서버에게 원하는 작업의 종류를 알려주는 역할)

- 클라이언트가 웹 서버에 특정 동작을 요청하기 위해 사용하는 표준 명령어

---

<aside>
💡

- 대표적인 메소드

`GET` : 데이터 **조회** 

`POST` : 데이터 **변경**!! 즉, 생성, 수정,삭제에 사용 (데이터 조회빼고 나머지)

>> 목적에 따라 알맞게 사용!

</aside>

## HTTP

네트워크 상에서 데이터(리소스)를 주고 받기 위한 약속

## GET

서버로부터 데이터를 요청, **조회**

---

### 특징

1. 데이터 전송 : URL의 쿼리 문자열(Query Sting)을 통해 데이터 전송
    
   
    >> 빨간 부분이 쿼리 문자열
    
2. 데이터 제한 : URL 길이제한 → 대량 데이터 전송에 적합 x
3. 브라우저 히스토리 : 요청 URL이 브라우저 히스토리에 남음
4. 캐싱 

: GET 요청의 응답을 로컬에 저장 ㅇ

: 동일한 URL로 다시 요청할 때, 서버에 접속하지 않고 저장된 결과 사용

예)) 웹 페이지에서 뒤로 가기 버튼 활성화 (브라우저 스택이 쌓여있어서 가능)

: 페이지 로딩 시간을 크게 단축

---

- 사용 예시 (**조회** 기능!)

: 검색 쿼리 전송 / 웹 페이지 요청 / API에서 데이터 조회

## POST

서버에 데이터를 제출하여 리소스를 **변경(생성, 수정, 삭제)**에 사용 → DB에 조작이 가해짐

: 즉, get 이외의 모든  작동을 담당

---

### 특징

1. 데이터 전송 : HTTP body를 통해 데이터 전송 (HTTP body..개발자 도구로 볼 수 ㅇ)
2. 데이터 제한 : GET에 비해 더 많은 양 데이터 전송 ㅇ
3. 브라우저 히스토리 : POST 요청은 브라우저 히스토리가 남지 않음
4. 캐싱

: POST 요청은 기본적으로 캐시 할 수 없음

: POST 요청이 일반적으로 서버의 상태를 변경하는 작업을 수행..

---

- 사용 예시

: 로그인 정보 제출 / 파일 업로드 / 새 데이터 생성 / API에서 데이터 변경 요청

# HTTP response statue code

: 응답 상태 코드

서버가 클라이언트의 요청에 대한 처리 결과를 나타내는 3자리 숫자

---

예))

<aside>
💡

- 400번대 :  클라이언트 잘못
- 500번대 : 서버 잘못
</aside>

---

- 역할

: 클라이언트에게 요청 처리 결과 전달

: 디버깅 도움

: 웹 애플리케이션 동작 제어에 사용

---

### 403 Forbidden

서버에 요청이 전달됐지만, **권한** 때문에 거절됨

## CSRF

<aside>
💡

POST 메소드 같이 상태 변경할 때 csrf 필요
GET 메소드는 **조회**만 하니까 사이트 상태 변경 X → CSRF필요 없음

</aside>

Cross-Site_Request-Forgery : “사이트 간 요청 위조”

: 사용자가 자신의 의지와 무관하게 공격자가 의도한 행동을 하여 특정 웹 페이지의 보안을 취약하게 하거나 수정, 삭제 등의 작업을 하게 만드는 공격 방법 (일종의 해킹 방식)

>> CSRF Token (정품이라는 인증 수단) `{% csrf_token %}`으로 해결

---

### CSRF Token 적용

: DTL의 csrf_token 태그를 사용해 사용자에게 토큰 값을 부여

: 요청 시 토큰 값도 함께 서버로 전송 됨

>> 응답(새로고침)할 때마다 value 값이 달라짐

---

### 요청할 때 CSRF Token을 함께 보내야 하는 이유

**장고 서버가 직접 제공한 페이지에서 데이터를 작성하고 있는지 확인**하는 수단

: 겉모습이 똑같은 위조 사이트나 비정상 요청에 대한 방어 수단

<aside>
💡

- 기존

요청 데이터 → 게시글 작성

- 변경

요청 데이터 + csrf 토큰 → 게시글 작성

</aside>

### POST만 Token을 확인하는 이유

>> db의 변경사항을 만드는 요청이기 때문에 토큰을 사용해 최소한의 신원 확인을 하는 것

# Redirect

<aside>
💡

 `GET` 은 페이지를 받는게 당연하지만, 

`POST`는 페이지를 생성하는 것

>> 그래서 게시글 저장 후 결과물로 페이지를 응답으로 받는게 어색

</aside>

---

`redirect()` 

: 클라이언트가 인자에 작성된 주소로 다시 요청을 보내도록 하는 함수

### create view 함수에 적용하면 됨

### 동작원리

1. redirect 응답을 받은 클라이언트는 detail url로 다시 요청을 보내게 됨
2. 결과적으로 detail view 함수가 호출→ detail view 함수의 반환결과인 detail 페이지를 응답 받게 되는 것

>> 결국 사용자는 게시글 작성 후 작성된 게시글의 detail 페이지로 이동하는 것으로 느끼게 ㅇ


# Delete

- GET요청은 `form` 태그만 가능.. form태그에만 action이 있기 때문 (a태그 안됨)

# Update (2)

수정

## edit()

사용자 입력 데이터를 받은 페이지를 렌더링
    
### 구현

`textarea` 태그는 value 속성이 없음.. 그래서 {{ article.content }}를 써줘야 ㅇ


## update()

사용자가 입력한 데이터를 받아 db에 저장

## GET & POST

### GET 요청이 필요한 경우

- 캐싱 및 성능

: 캐시 가능, 이전에 요청한 정보 다시 사용 가능

: 동일한 검색 셜과를 여러 번 요청하는 경우, 캐시를 이용해 빠르게 응답 ㅇ

- 가시성 및 공유

: get 요청은 URL에 데이터가 노출 → 공유 용이

- RESTful API 설계

: HTTP 메서드의 의미에 따라 동작하도록 ㅇ → API 일관성 유지 ㅇ

## 캐시(Cache)

데이터나 정보를 임시로 저장해두는 메모리, 디스크 공간

이전에 접근한 데이터를 빠르게 검색, 접근 가능
